<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Design Goals</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="7493ffc4-7c29-4d5e-b98f-b05779501025" /><meta name="Description" content="Brimstone aims to be a high-performance, high-parity simulator for Hearthstone and other CCGs, with software developers, game designers and artificial intelligence academics as the target audience." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link rel="stylesheet" type="text/css" href="../styles/branding-Website.css" /><script type="text/javascript" src="../scripts/jquery-1.11.0.min.js"></script><script type="text/javascript" src="../scripts/branding-Website.js"></script><script type="text/javascript" src="../scripts/clipboard.min.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">Hearthstone Working Group<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6.htm" title="Hearthstone Working Group" tocid="roottoc">Hearthstone Working Group</a></div><div class="toclevel1" data-toclevel="1" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6.htm" title="Brimstone Developer Documentation" tocid="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6">Brimstone Developer Documentation</a></div><div class="toclevel2 current" data-toclevel="2"><a data-tochassubtree="false" href="7493ffc4-7c29-4d5e-b98f-b05779501025.htm" title="Design Goals" tocid="7493ffc4-7c29-4d5e-b98f-b05779501025">Design Goals</a></div><div class="toclevel2" data-toclevel="2"><a data-tochassubtree="false" href="18642f79-254c-41de-b114-830086f71262.htm" title="Project Structure" tocid="18642f79-254c-41de-b114-830086f71262">Project Structure</a></div><div class="toclevel2" data-toclevel="2"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="aaa823e4-abc6-4151-9199-88f331bb4254.htm" title="Basic Concepts" tocid="00140305-b1cd-48a1-a6a6-5f8de37c7011">Basic Concepts</a></div><div class="toclevel2" data-toclevel="2"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="f230a982-28b6-4fd1-b0ce-c3decd883ab4.htm" title="Benchmarks and Profiling" tocid="5b14b2b1-ba97-4840-9f69-6807d36181c2">Benchmarks and Profiling</a></div><div class="toclevel2" data-toclevel="2"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="8409d776-e34a-419c-ba67-1806ba9b985d.htm" title="Contributor Guide" tocid="8409d776-e34a-419c-ba67-1806ba9b985d">Contributor Guide</a></div><div class="toclevel2" data-toclevel="2"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="c8668cdf-fc71-6332-26e5-5795a3ab0770.htm" title="API Reference" tocid="c8668cdf-fc71-6332-26e5-5795a3ab0770">API Reference</a></div><div class="toclevel2" data-toclevel="2"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="cfbc1e9f-a4cf-4463-8007-491c7ac285fc.htm" title="Version History" tocid="cfbc1e9f-a4cf-4463-8007-491c7ac285fc">Version History</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="../icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="../icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="logoColumn"><img alt="HearthSim" width="64" height="64" src="../icons/HearthSim.png" /></td><td class="titleColumn">Design Goals</td></tr></table><span class="introStyle"></span> <p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[This is preliminary documentation and is subject to change.]</p><div class="introduction"><p>Brimstone aims to be a high-performance, high-parity simulator for Hearthstone and other CCGs, with software developers, game designers and artificial intelligence academics as the target audience. We have drawn on our experience of the two existing major simulators - Fireplace and Metastone, and their peripheral projects - to craft a new simulator which solves the design problems inherent in the existing projects.</p><p>We have the following design goals for Brimstone:</p><ul class="autoOutline"><li class="outlineSectionEntry"><a href="#highperf">High performance</a></li><li class="outlineSectionEntry"><a href="#parity">High level of parity with actual Hearthstone behaviour</a></li><li class="outlineSectionEntry"><a href="#tickbased">Tag-driven, tick-based design with flexible hooks and infinite undo</a></li><li class="outlineSectionEntry"><a href="#cloning">Extremely fast state cloning</a></li><li class="outlineSectionEntry"><a href="#gametree">Game tree creation and traversal</a></li><li class="outlineSectionEntry"><a href="#probabilistic">Probabilistic state outcomes</a></li><li class="outlineSectionEntry"><a href="#carddef">Declarative card definition language and easy-to-use API</a></li><li class="outlineSectionEntry"><a href="#easyuse">Easy black box installation and usage</a></li><li class="outlineSectionEntry"><a href="#docs">Great documentation</a></li><li class="outlineSectionEntry"><a href="##future">Future developments</a></li></ul><p>To understand some of the items below, it may help to familiarize yourself with Brimstone's [TODO: Tags and Entities Model].</p></div><div class="collapsibleAreaRegion" id="highperf"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID0RB')" onkeypress="SectionExpandCollapse_CheckKey('ID0RB', event)" tabindex="0"><img id="ID0RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />High performance</span></div><div id="ID0RBSection" class="collapsibleSection"><p>Fireplace is reasonably accurate in behaviour but very slow (~5 games/sec, Intel Core i7-2600K, 16GB RAM), Metastone is inaccurate but very fast (~2000-3000 games/sec, same hardware). Brimstone aims to be fast and accurate.</p><ul><li><p>Brimstone can run games, action queues and tree searches as multi-threaded operations using all available CPU cores</p></li><li><p>Brimstone offers an asynchronous (non-blocking) API for time-critical functions using C#'s async/await (TPL) operators, so your application can continue to run while Brimstone performs work</p></li><li><p>No reflection is used except on startup</p></li><li><p>Brimstone employs a high number of performance optimizations including caching, copy-on-write game state manipulation, lazy iteration, eager/lazy evaluation according to need, linked list and immutable collection cloning, the use of value types where possible and so on</p></li><li><p>All commits to Brimstone's code base are benchmarked and profiled to monitor the performance impact of code changes over time and identify bottlenecks</p></li></ul><div class="alert"><table><tr><th><img src="../icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>One of our future goals is to enable Brimstone to divide work across process boundaries so that multiple servers can be used to process tasks</p></td></tr></table></div></div><div class="collapsibleAreaRegion" id="parity"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />High level of parity with actual Hearthstone behaviour</span></div><div id="ID1RBSection" class="collapsibleSection"><p>
          Fireplace tries to produce similar game state log output (<em>PowerHistory</em>) to Hearthstone but is bound by a number of design limitations. Metastone does not attempt to produce Hearthstone-compatible log output.
        </p><ul><li><p>Brimstone produces deterministic (predictably ordered) PowerHistory tasks (action blocks, tag changes etc.) in virtually identical order as seen in real game logs to the highest extent possible</p></li><li><p>
              The PowerHistory from Brimstone can be connected to a Stove server, allowing users to play against Brimstone AIs via the Hearthstone client<sup>*</sup></p></li><li><p>Bugs in Hearthstone are not replicated unless they are critical to compatibility</p></li></ul><div class="alert"><table><tr><th><img src="../icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>* In a future release, a bridge server to connect Brimstone to Stove will be developed based on the existing Kettle protocol developed by HearthSim.</p></td></tr></table></div></div><div class="collapsibleAreaRegion" id="tickbased"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID2RB')" onkeypress="SectionExpandCollapse_CheckKey('ID2RB', event)" tabindex="0"><img id="ID2RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Tag-driven, tick-based design with flexible hooks and infinite undo</span></div><div id="ID2RBSection" class="collapsibleSection"><p>In Fireplace and Metastone, game actions are committed immediately and the game state history is lost. This makes it impossible to revert a game state without a deep copy, Additionally, user actions such as playing a card or performing an attack are treated as atomic behaviours. Intercepting an action mid-way through is not possible, which causes problems when user input is required (for example, Discover), and when we want to manipulate the game state for debugging and AI purposes.</p><ul><li><p>Brimstone implements Hearthstone as a finite state machine (FSM) - as do the official Hearthstone servers. Rather than stepping through the game in a procedural manner as in the case of the other simulators, Brimstone uses an event-driven model to drive the state machine forwards. This model can be edited at will to produce new FSMs with different behaviours, without modifying Brimstone's core code.</p></li><li><p>Brimstone queues action blocks and resolves them after an operation completes, mirroring the behaviour of the official Hearthstone session servers and ensuring that actions are nested correctly.</p></li><li><p>Queues can be stacked arbitrarily so that you can insert new actions without affecting the existing queue.</p></li><li><p>If the game state is needed, it can be cloned before the queue is resolved.</p></li><li><p>
              Completed queue actions can be stored in a log and reviewed at any time during or after the game.
            </p></li><li><p>
              Changes to tags cause their previous values to be pushed onto a PowerHistory log. The game state can be reversed one tag change at a time, or according to a filter or previously set marker. A rewound game state can be fast-forwarded by re-processing the subsequent log entries.<sup>*</sup></p></li><li><p>Event handlers can be connected to each tag and block type (or any other PowerHistory event), allowing any change to be intercepted and modified, or for the simulation to be stalled while other work is completed. This enables tick-based processing.</p></li><li><p>
              Event handlers can be connected to any action, before or after queueing, or before or after execution. The action's source, arguments or action type itself can be changed. Actions can be replaced entirely or cancelled. The game state can be cloned between actions or mid-action. The action queue can be paused.
            </p></li><li><p>
              Event handlers can be connected to game object (<em>entity</em>) creation or change events if you wish to work with game objects directly rather than the queue or PowerHistory.
            </p></li></ul><div class="alert"><table><tr><th><img src="../icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>* Undo is not yet implemented</p></td></tr></table></div></div><div class="collapsibleAreaRegion" id="cloning"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Extremely fast state cloning</span></div><div id="ID3RBSection" class="collapsibleSection"><p>A deep copy of the game state in Fireplace takes approximately 200ms to complete (Intel Core i7-2600K, 16GB RAM). Fireplace struggles with cloning because the game object contains cycles and unnecessary data making efficient cloning difficult. Additionally, setting attributes manually on a new shallow copy of the game object is not always possible or may cause undesired trigger effects. For AI work, we would like to go faster.</p><ul><li><p>
              Brimstone's object hierarchy is designed to be free of circular references (cycles), and require the minimal amount of modification when deep cloning. This is partly achieved by using value types (integer indexes rather than object references) to reference game objects where practical, and partly by using immutable collections where a copying a reference to the collection is all that is required to guarantee a clone will be generated later if needed. Game entities contain only a list of their current tag values and no other fields where possible. These techniques in combation provide near-<em>memcpy</em>-level copying performance.
            </p></li><li><p>
              Brimstone offers copy-on-write cloning which drastically reduces cloning time and clones individual game entities only when they are modified by the clone.
            </p></li><li><p>
              Brimstone offers out-of-the-box multi-threaded game state cloning using all available CPU cores.
            </p></li><li><p>
              Cloning large collections such as logs is performed by using a linked list such that each clone stores only its local delta (changes); earlier items in the log are fetched from the ancestor clones.
            </p></li></ul></div><div class="collapsibleAreaRegion" id="gametree"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Game tree creation and traversal</span></div><div id="ID4RBSection" class="collapsibleSection"><p>Brimstone includes tools to allow you to create and traverse game trees.</p><ul><li><p>Game trees in Brimstone are represented as n-trees backed by a doubly linked list. The tree can be traversed simply by accessing the Parent or Children properties of a node object. Nodes can be added individually or in groups with one line of code.</p></li><li><p>Brimstone allows you to define your own node types with arbitrary data and use them in game trees. Node types which specify edge weighting and probability of occurrence are included.</p></li><li><p>Brimstone can use entity hashing, PowerHistory delta comparison or PowerHistory hashing to produce fast game state equivalence comparisons. Fuzzy comparisons can be made to ignore the position of cards in hand, or entities with different IDs that are otherwise identical. Fuzzy game comparisons are an O(1) operation.</p></li></ul></div><div class="collapsibleAreaRegion" id="probabilistic"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID5RB')" onkeypress="SectionExpandCollapse_CheckKey('ID5RB', event)" tabindex="0"><img id="ID5RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Probabilistic state outcomes</span></div><div id="ID5RBSection" class="collapsibleSection"><p>AI tree searches require us to be able to produce all of the possible outcomes for a random event, such as a card draw or random damage effect. It can also be beneficial to produce an 'average' effect to save time creating every possibility. No other simulator that we are aware of has the ability to perform these calculations.</p><ul><li><p>Brimstone can easily output a probability map for each possible random outcome, taking an initial input game state and an action to perform, and outputting a list of possible game states with the probability of each occurring.</p></li><li><p>Brimstone uses game state equivalence testing during tree searches to automatically prune already-visited nodes.</p></li><li><p>Brimstone comes with naive equivalence, depth-first tree search and breadth-first tree search APIs out of the box to traverse game trees, and you can also implement your own search algorithms by implementing an interface.</p></li><li><p>Tree searches can be parallelized to use all available CPU cores. Thread-safe parallel search implementations are provided out-of-the-box.</p></li></ul></div><div class="collapsibleAreaRegion" id="carddef"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID6RB')" onkeypress="SectionExpandCollapse_CheckKey('ID6RB', event)" tabindex="0"><img id="ID6RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Declarative card definition language and easy-to-use API</span></div><div id="ID6RBSection" class="collapsibleSection"><p>The Fireplace end-user API is well designed and we have endeavoured to use a similar API in Brimstone so that existing Fireplace users can migrate their code to Brimstone easily without facing a steep learning curve.</p><p>The card definition language in Brimstone is also similar to that of Fireplace, using declarative syntax and lazy evaluation. However, we provide additional flexibility:</p><ul><li><p>In Brimstone, card definitions are logical graphs which are reflected over and pre-compiled on startup for faster performance.</p></li><li><p>Every argument to an action in a graph is itself a graph, allowing arguments to be intercepted and changed during simulation in the same way as any other action. For card designers, this eliminates the limitations where some arguments are expected to be compile-time constants or other known values.</p></li><li><p>Brimstone uses a stack to push (store) the results of each action (including actions which are arguments). When an action is evaluated, only arguments which are missing are popped (fetched) from the stack. This allows you to chain actions such that later actions can be specified in the card definition with missing arguments, which will be populated by the results of earlier actions. This not only eliminates the need for fudge variables for temporary storage, and provides greater flexibility, but also enables definitions to be written in a variety of syntaxes for easier coding and greater readability.</p></li><li><p>.NET lambda functions and expressions can also be queued as game actions, allowing arbitrary code insertion during the simulation.</p></li><li><p>Card definitions in Brimstone are mutable, which means they are not hard-wired on startup. A card's definition can be changed before or during a game at any time. This is useful for testing when you want to change the default game behaviour without editing the official card definitions.</p></li><li><p>In Brimstone, the game and the players are also cards. By modifying their trigger definitions, you can completely change the order of execution of game flow.</p></li></ul></div><div class="collapsibleAreaRegion" id="easyuse"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID7RB')" onkeypress="SectionExpandCollapse_CheckKey('ID7RB', event)" tabindex="0"><img id="ID7RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Easy black box installation and usage</span></div><div id="ID7RBSection" class="collapsibleSection"><p>One thing holding back potential developers from the other simulators is the high barrier of entry to get everything installed and running. Brimstone's core simulator is a single DLL that can be used as a black box API. We use the minimum number of dependencies, try to automate the compile process as much as possible and provide regular releases that can just be downloaded and used without modification or complicated setup. Brimstone is compatible with both Windows and Linux and performs equally on both platforms with no special modifications or setup requirements. All you need to get going is a .NET language compiler.</p></div><div class="collapsibleAreaRegion" id="docs"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID8RB')" onkeypress="SectionExpandCollapse_CheckKey('ID8RB', event)" tabindex="0"><img id="ID8RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Great documentation</span></div><div id="ID8RBSection" class="collapsibleSection"><p>Many users struggle with writing new card definitions or gameplay scripts with other simulators due to poor documentation API documentation and a lack of examples and tutorials. We try to ensure excellent documentation and tutorials so that a community can grow around Brimstone.</p><p>Our API documentation is automatically generated from XML code comments using Sandcastle and updated on GitHub Pages automatically with every commit. Contributors are required to provide XML documentation for every public type, method and property they contribute.</p><div class="alert"><table><tr><th><img src="../icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>The documentation is in a very early stage and we still have a large amount of code to comment.</p></td></tr></table></div></div><div class="collapsibleAreaRegion" id="#future"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID9RB')" onkeypress="SectionExpandCollapse_CheckKey('ID9RB', event)" tabindex="0"><img id="ID9RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Future developments</span></div><div id="ID9RBSection" class="collapsibleSection"><h4 class="subHeading" id="import">Multi-source game state importing</h4><div class="subsection"><p>Other simulators have no simple way of importing game states from either completed games or those in progress, either from their output or from actual Hearthstone games or replay logs. We aim to create an import interface which users can implement to create their own imports, as well as providing out-of-the-box import functionality for common sources.</p><ul><li><p>
                  Import from an <em>entity.log</em> from DeepLog
                </p></li><li><p>Import from the PowerHistory log or a partial PowerHistory log from another Game object</p></li><li><p>
                  Import from an <em>hsreplay</em> XML file
                </p></li><li><p>Import from a Hearthstone Power.log file</p></li></ul><p>This allows us to take real games, analyse them, and check our code for bugs as well.</p><p>To achieve these goals, we have designed game entity objects to be self-describing, such that a new game can be initialized simply by passing it a list of entities and allowing it to configure itself.</p><p>The PowerHistory log currently supports producing a crunched version of itself with only the current tags of each entity. Importers should create PowerHistory logs from their import sources, retrieve the crunched log then initialize each game entity using the current tag set for each corresponding entity in the log.</p></div><h4 class="subHeading" id="connectors">Connectors for CNTK/TensorFlow neural network packages</h4><div class="subsection"><p>Brimstone is optimized for AI performance and ML use. Microsoft's CNTK has C++ and C# APIs while Google's TensorFlow has a Python API and limited C++ API. In the future we would like to be able to evaluate models created from graphs in these ML APIs with the Brimstone simulator. It must also be easy for two ML AIs to play against each other.</p></div><h4 class="subHeading" id="extensible">Extensibility features for other collectible card games</h4><div class="subsection"><p>Preliminary work has been done here, but we would like to fully separate out all of the card definitions, actions, rulesets and FSM behaviour of Hearthstone into a modular system such that it can be replaced, allowing new card games to be developed using Hearthstone's core tag and entity-based engine. This would allow Brimstone to function as a generic card game engine that could be used as a basis to create or simulate arbitrary new or existing card games.</p></div></div></div></div><div id="pageFooter" class="pageFooter"><a href="http://discord.me/hearthstoneworkinggroup">Join us on Discord</a><br /><p>Hearthstone Working Group 2016 - Part of HearthSim.info</p></div></body></html>