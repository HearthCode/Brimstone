<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Game Structure: Cards, Entities and Tags</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="aaa823e4-abc6-4151-9199-88f331bb4254" /><meta name="Description" content="This document explains the model we have created for Brimstone and how it can be modified at run-time. The model is designed for high-performance and to be highly flexible, with many available hooks." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link rel="stylesheet" type="text/css" href="../styles/branding-Website.css" /><script type="text/javascript" src="../scripts/jquery-1.11.0.min.js"></script><script type="text/javascript" src="../scripts/branding-Website.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">Hearthstone Working Group<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6.htm" title="Hearthstone Working Group" tocid="roottoc">Hearthstone Working Group</a></div><div class="toclevel0" data-toclevel="0"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6.htm" title="Brimstone Developer Documentation" tocid="bbd3d95b-45e3-46e9-bd51-35ee4749d7b6">Brimstone Developer Documentation</a></div><div class="toclevel1" data-toclevel="1" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="aaa823e4-abc6-4151-9199-88f331bb4254.htm" title="Basic Concepts" tocid="f8709b9c-acb4-46c0-8377-2e1cc6cd0676">Basic Concepts</a></div><div class="toclevel2 current" data-toclevel="2"><a data-tochassubtree="false" href="aaa823e4-abc6-4151-9199-88f331bb4254.htm" title="Game Structure: Cards, Entities and Tags" tocid="aaa823e4-abc6-4151-9199-88f331bb4254">Game Structure: Cards, Entities and Tags</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="../icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="../icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="logoColumn"><img alt="HearthSim" width="64" height="64" src="../icons/HearthSim.png" /></td><td class="titleColumn">Game Structure: Cards, Entities and Tags</td></tr></table><span class="introStyle"></span><p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[This is preliminary documentation and is subject to change.]</p><div class="introduction"><p>This document explains the model we have created for Brimstone and how it can be modified at run-time. The model is designed for high-performance and to be highly flexible, with many available hooks.</p><div class="alert"><table><tr><th><img src="../icons/AlertNote.png" alt="Note" /> Note</th></tr><tr><td><p>This document is a work in progress and will be updated with each release. Items without annotations are complete, implemented and working.</p></td></tr></table></div><div class="alert"><table><tr><th><img src="../icons/AlertCaution.png" alt="Caution note" /> Caution</th></tr><tr><td><p>This is a port of the Brimstone Behavioural Model document from Google Docs for Brimstone pre-alpha Update 2. It has not yet been fully formatted or sectioned. Elements of this document will be split up into a conceptual overview and a developer guide for Update 3.</p></td></tr></table></div></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID0RB')" onkeypress="SectionExpandCollapse_CheckKey('ID0RB', event)" tabindex="0"><img id="ID0RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Basic Structure</span></div><div id="ID0RBSection" class="collapsibleSection"><h4 class="subHeading">Cards, Entities and Tags</h4><div class="subsection"><p>Brimstone is based on a tag-based system. Each object in the game has a list of tags which define things such as board position, health, damage taken and so on.</p><p>Brimstone draws a sharp distinction between cards and in-game entities.</p><ul><li><p><a href="967ed6a7-78de-ecc0-5937-c2bd415a0b12.htm">Card</a> defines the starting tags and behaviours such as the battlecry and deathrattle of a card. Cards are not linked to a specific game and are immutable (they can't be changed)
                </p></li><li><p><a href="89d0b279-8e40-dd63-28dc-d1712b29727d.htm">Entity</a> defines an in-game entity which is composed of a <a href="967ed6a7-78de-ecc0-5937-c2bd415a0b12.htm">Card</a> and additional information such as added and changed tags, the <a href="117e76f2-6577-04ac-2097-cd077c7af526.htm">Game</a> instance which owns and manages the entity, the controller of the entity (a <a href="3fb7003c-2e6f-b3bb-f240-3910ae0c260e.htm">Player</a>) and so on
                </p></li></ul><p>
              All of the elements of a game are entities, including everything in each player's deck, hand and side of the board, the players themselves, their heroes, hero powers<sup><a href="#cmnt1">[a]</a></sup> and the game itself.
            </p><p>
              Cards cannot be played directly. They are first converted to entities by calling a class constructor such as <a href="af2d1258-051d-bb54-8381-4a50c2c686e5.htm">new Minion(Card)</a> or <a href="59e078fc-2167-0f11-0b1b-cd1e0f079de5.htm">new Spell(Card)</a>, then added to the game. These classes derive from the <a href="53f21c45-0009-f88c-6825-69bffe9466c5.htm">IEntity</a> interface which specifies that the class implements all of the required APIs for an in-game entity.
            </p><p>In practice, you do not need to worry about this as the conversions are normally handled for you.</p><p>
              Every <a href="89d0b279-8e40-dd63-28dc-d1712b29727d.htm">Entity</a> exposes its tags with the index operator, eg. <span class="code">someMinion[GameTag.DAMAGE]</span> will return the number of points of damage the minion has taken.
            </p><p>
              Game entities can be accessed via the <a href="6315b610-9cce-5e93-42ac-01002a739b9f.htm">Entities</a> property.
            </p><div class="alert"><table><tr><th><img src="../icons/AlertCaution.png" alt="Important note" /> Important</th></tr><tr><td><p>
                End users should not read or modify tags directly. Instead, use the tag property helpers when you want to read or modify tags (the above would be <span class="code">SomeMinion.</span><a href="f0bb2ec7-7435-28f0-4ba8-00baaf18161e.htm">Damage</a>) as tag accesses sometimes cause internal processing which must be done when the tag is accessed.
              </p></td></tr></table></div></div><h4 class="subHeading">Zone Management</h4><div class="subsection"><p>
              All entities in a Brimstone game are separated into zones. A <a href="e7c2c9f7-fbc1-916a-8995-35e92e08174c.htm">Zone<span id="LST9C3ADAF2_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST9C3ADAF2_0?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>T<span id="LST9C3ADAF2_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST9C3ADAF2_1?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a> can be the player's hand, the board, deck, graveyard for used cards, secrets area and the setaside zone used during actions such as Discover. Each player has their own set of <a href="492a36bf-77f9-d0b7-5d73-31cf018e7b46.htm">Zones</a>, as does the game itself. For easy access, you can fetch or modify just the items in a particular zone using shortcuts such as <span class="code">Game.Player1.Hand</span> or <span class="code">Game.Player2.Board</span>. Zones are 1-indexed from left to right, so <span class="code">Game.Player1.Board[2]</span> is the 2nd minion to the left on player 1's side of the board.
            </p><p>Brimstone handles zones intelligently without duplicating game entity data, selecting zone data from the game's main entity list only when requested, then caching the results. Entities can be inserted at any position in any zone and the remaining items' zone positions will be updated correctly without needing to refresh the cache.</p><p>Items with no zone position (eg. items in the graveyard, spells in play, heroes in play etc.) are not tracked in the zone cache.</p><p>
              To disable zone caching: <span class="code">Settings.ZoneCaching = false</span></p></div><h4 class="subHeading">Power History</h4><div class="subsection"><p>
              All entity creations, tag changes etc. are stored in the game's <a href="83086944-78c1-1e34-2ef6-d5fc5f82bd85.htm">PowerHistory</a> log. The PowerHistory is so-named because it is the mechanism that Hearthstone uses to communicate and update game state. This data can be sent directly on the wire as-is to emulate a Hearthstone game session.<sup><a href="#cmnt2">[b]</a></sup></p><p>
              Brimstone is designed to be self-configuring, meaning that in the future you will be able to feed in power logs from real games and Brimstone will correctly recreate the entire game state.<sup><a href="#cmnt3">[c]</a></sup></p><p>
              The power history log implements <a href="http://msdn2.microsoft.com/en-us/library/9eekhta0" target="_self">IEnumerable<span id="LST9C3ADAF2_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST9C3ADAF2_2?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>T<span id="LST9C3ADAF2_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST9C3ADAF2_3?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a> and yields a collection of <a href="1295c545-56bb-506c-c570-7474c3bb38d4.htm">PowerAction</a>.
            </p></div></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Actions Model</span></div><div id="ID1RBSection" class="collapsibleSection"><h4 class="subHeading">Action Queue and Result Stack</h4><div class="subsection"><p>Brimstone uses an action queue and a result stack to process in-game events.</p><ul><li><p>Action queue: queues forthcoming actions, eg. Play, Draw, Damage and so on. Arguments to each action are themselves actions.</p></li><li><p>Result stack: stores the results of previous actions in a LIFO order. Each action has a fixed number of arguments. When an action runs, the correct number of arguments is popped from the stack and passed to the action. When the action completes, any results from the action are pushed onto the stack</p></li><li><p>When the queue is empty, any remaining results on the result stack are returned to the caller</p></li></ul><p>Example:</p><p>You call the Play action to move a card from a player's hand to the battlefield.</p><p>Play takes two arguments: the player who is playing the card, and the card to play.</p><p>These arguments are converted to actions, in this case both are LazyEntitys initialized with the player and card entities that will be arguments to Play (they are lazy because they are not resolved until the action runs). The argument actions are pushed onto the queue, followed by the Play action itself.</p><p>The queue can be processed immediately or at the caller's discretion.</p><p>When the queue is processed, each LazyEntity action takes 0 arguments. The first LazyEntity action executes and pushes the player entity onto the result stack. The second LazyEntity action executes and pushes the card entity to play onto the result stack. Finally, the Play action executes; it takes 2 arguments so it pops the last two results off the stack then is called. Play returns the entity of the played card, which is pushed onto the stack. At this point, the queue is empty, so the contents of the stack is emptied and transferred to the calling function.</p><p>The easiest way to understand this is to use the Brimstone Visualizer to step through the action queue one action at a time. The visualizer shows the action queue and result stack at each step.</p><p>Nested actions</p><p>Some actions may call other actions. For example the Play action may queue the battlecry behaviour of the played card. This will be pushed onto the queue and processed when Play completes, but before it returns to the caller. Therefore, the result stack may contain the results of these nested actions. Due to the fact the stack operates as a LIFO stack, results are always popped in the correct order.</p><p>Multi-queueing</p><p>
              You can queue as many actions as you like before processing the queue. For example, you can queue playing all the cards in the player's hand before anything happens, and then process the entire queue at once. See the <a href="#h.jpen8v6ciamt">Game State Manipulation</a> section for further details.
            </p><p>Queue history</p><p>A history log of all the actions for the game is stored and accessible for debugging purposes.</p></div><h4 class="subHeading">Action Graphs</h4><div class="subsection"><p>An ActionGraph can be thought of as a unit of behaviour consisting of one or more actions. Each argument to an action is itself an ActionGraph.</p><p>Example:</p><p>Give(CurrentPlayer, Cards.ByName("Knife Juggler")) * 3.Then(Damage(AllMinions, 1))</p><p>Here, Give, CurrentPlayer, Card, Damage, AllMinions and the numbers 3 and 1 are all ActionGraphs.</p><p>The Then method chains two ActionGraphs together in sequential order. The * operator causes the ActionGraph to be replaced by a call to the Repeat action with the ActionGraph as an argument. ActionGraphs are unravelled into a list of QueueActions by taking the inner-most arguments first and otherwise using left-to-right order.</p><p>The example above will be unravelled in this order:</p><p>CurrentPlayer</p><p>Cards.ByName("Knife Juggler")</p><p>Give</p><p>3</p><p>Repeat</p><p>When encountering Repeat, the ActionGraph is moved into Repeat's arguments and unravelling continues:</p><p>Repeat [3, CurrentPlayer, Cards.ByName("Knife Juggler"), Give]</p><p>AllMinions</p><p>1</p><p>Damage</p><p>Behaviour compilation</p><p>For performance reasons, all card definition behaviours are unravelled into lists of QueueActions when Brimstone starts up. The action queue accepts single QueueActions, lists of QueueActions or ActionGraphs as queueing arguments. ActionGraphs created during runtime are unravelled into lists of QueueActions when they are added to the queue, and therefore do not receive the performance benefits of unravelling on startup. This real-time unravelling occurs whenever you queue an ActionGraph, which is to say, every time you perform an in-game action not predefined as a card behaviour.</p><p>Implicit casting of values to ActionGraphs</p><p>The ActionGraph class provides syntactic sugar to make composing ActionGraphs easier:</p><ul><li><p>Integer numbers are automatically converted to a FixedNumber action, which simply returns the number (which is then pushed to the result stack)</p></li><li><p>Cards are automatically converted to a FixedCard action, which returns the Card</p></li><li><p>Entitys are automatically converted to a LazyEntity action, which returns the state of the Entity at the time the action is executed</p></li><li><p>Functions (including lambdas) with take a single IEntity as an argument and return no value are automatically converted to a Func action, which executes the specified function at the time the action is executed. This is mainly used to add specialized behaviour to other actions and is described below</p></li><li><p>Single QueueActions are automatically converted to an ActionGraph with the action as its only content, so you can use QueueActions anywhere you can use an ActionGraph</p></li></ul><p>ActionGraph helper methods</p><ul><li><p>The Repeat method creates a Repeat action from the existing ActionGraph. Note that The quantity argument is itself an ActionGraph, so graphs such as Draw(CurrentPlayer).Repeat(AllMinions) will work (this example draws a card for each mionion on the battlefield)</p></li><li><p>The multiply operator (*) is a syntax shortcut for Repeat. The above example is more easily written as: Draw(CurrentPlayer) * AllMinions</p></li><li><p>The Then method adds the ActionGraph supplied at the end of the current ActionGraph, such that the two run sequentially. The graph Draw(CurrentPlayer).Then(Damage(AllMinions, 1)) will chain the graphs such that the Draw graph executes first then the Damage graph</p></li></ul><p>Now that we understand casting and helper methods, we can see how the example graph above is finally unravelled into a list of QueueActions. The items in square brackets are fixed arguments passed to the QueueAction when it is initialized and as such are not part of the queued arguments or result stack.</p><p>Give(CurrentPlayer, Cards.ByName("Knife Juggler")) * 3.Then(Damage(AllMinions, 1))</p><p>Unravels to:</p><p>FixedNumber [3]</p><p>Repeat [</p><p>LazyEntity [the current player's entity ID]</p><p>FixedCard [the Card definition for Knife Juggler]</p><p>Give</p><p>]</p><p>Select [SelectionSource = Game, lambda function which selects all minions]</p><p>FixedNumber [1]</p><p>Damage</p><p>Experiment with the Brimstone Visualizer to see how this works for different ActionGraphs.</p><p>ActionResults</p><p>When a QueueAction returns a value, it is pushed onto the result stack as an ActionResult. ActionResults are variant-like objects which can hold one of the following items:</p><ul><li><p>Boolean value</p></li><li><p>Integer value</p></li><li><p>Card definition</p></li><li><p>List of entities</p></li><li><p>Single entity (see below)</p></li></ul><p>When storing a single entity, the entity is converted to a list of entities with only one item.</p><p>ActionResults can also specify no value (ActionResult.None), in which case the result is not pushed onto the stack, or an empty value (ActionResult.Empty), in which case a result with no value is pushed onto the stack. The former is used when you wish to write an action which does not return a value; the latter is mostly used for event trigger matching (see below).</p><p>ActionResults support implicit casting to and from any of the above types, which means you do not need to use casts when passing or returning these types. When implicitly casting to a single entity, the first entity in the entity list is returned. Therefore, list storage is transparent, but if you use the ActionResult in a list or set operation, the single entity will automatically be accepted as a list.</p><p>ActionResults support value equality comparisons with the == operator (and inequality with the != operator), which will compare both the type and value of each result. Note that entity lists only perform a reference comparison - the actual list contents are not compared.</p><p>ActionResults are enumerable if they contain a list of entities which means they can be used in foreach statements and so on.</p>
              Entity Selection<sup><a href="#cmnt4">[d]</a></sup><p>Selection of entities is a crucial part of game simulation. In Brimstone, entity selection is itself an action which is pushed to the queue. Entity selection can either use predefined helpers such as OpponentMinions, or any function, lambda or anonymous method desired.</p><p>The selection function can take a Game, Player or IEntity and the input argument is automatically detected based on the properties and methods you access, so no casting is required.</p><p>Examples:</p><p>Select an entity's controller: Select(e =&gt; e.Controller)</p><p>Select the current player's minions on board: Select(g =&gt; g.CurrentPlayer.Board)</p><p>Select the opponent minions of an arbitrary player: Select(p =&gt; p.Opponent.Board)</p><p>The Select function generates a Selector action. The input to the selection function is determined as follows:</p><ul><li><p>If the input is a Game, use the Game bound to the action queue</p></li><li><p>If the input is an IEntity, use the source which generated the action</p></li><li><p>If the input is a Player:</p></li></ul><ul><li><p>If the source of the action is a Game, use the current player</p></li><li><p>If the source of the action is a Player, use the specified player</p></li><li><p>If the source of the action is an IEntity, use the player which controls the entity</p></li></ul><p>This mechanic ensures that the correct player is always selected, for example:</p><ul><li><p>A player is always the source of their own mulligan creation. The player whose mulligan choices are being selected will be used as the input to the selection function which returns all the cards in their hand excluding The Coin</p></li><li><p>If the source of OpponentMinions is a player, that player will be used as the input. If the source is a game, the current player will be used. If the source is an entity, the player who owns the entity will be used.</p></li></ul></div></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID2RB')" onkeypress="SectionExpandCollapse_CheckKey('ID2RB', event)" tabindex="0"><img id="ID2RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Event Model</span></div><div id="ID2RBSection" class="collapsibleSection"><p>A trigger is something that occurs when a specific in-game action happens. Card definitions can create triggers on any ActionGraph. Each card definition takes a list of as many triggers as required. Here is an example from Acolyte of Pain:</p><p>Triggers = {</p><p>        When(Damage(Self), Draw(Controller))</p><p>}</p><p>This causes the controller of Acolyte of Pain to draw a card whenever it is damaged.</p><p>There are two types of triggers:</p><ul><li><p>When triggers execute in the same action block as the triggering action itself</p></li><li><p>After triggers execute after the action block of the triggering action</p></li></ul><p>Trigger matching</p><p>Triggers must be matched to determine whether they should fire or not. For example, if we attach a trigger to a specific entity being damaged as above, we do not want the trigger to fire if a different entity is damaged.</p><p>A trigger's ActionGraph is unravelled (Damage(Self) in the above example) and all of the actions besides the last are used as match arguments to determine if the conditions for the trigger are met. The trigger is attached to the final action.</p><p>In the example above, Self will be used as a match argument and the trigger will be attached to the Damage action.</p><p>Notice that not all arguments need to be supplied. The usual format of Damage is Damage(characters, amount) (where characters and amount are ActionGraphs). Missing match arguments are considered as always matching.</p><p>For ease of use, you can supply keyword arguments when creating triggers, for example:</p><p>When(Damage(Amount: 1), Draw(Controller))</p><p>will draw a card for the damaged character's controller whenever any character is damaged by exactly 1 point.</p><p>Remember that everything is an ActionGraph, so:</p><p>When(Damage(Amount: NumOpponentMinions), Draw(Controller))</p><p>Will draw a card for the damaged character's controller whenever any character is damaged by the amount of minions the opponent has on the board.</p><p>Valid match arguments</p><p>For performance reasons, match arguments are not processed via the action queue and as such you cannot use any actions which take queued arguments. For example, you can use:</p><ul><li><p>A number (FixedNumber)</p></li><li><p>A card (FixedCard)</p></li><li><p>An entity (FixedEntity)</p></li><li><p>A function (Func)</p></li><li><p>A selector (Selector or a built-in helper such as AllMinions), ie. a list of entities</p></li></ul><p>Run-time trigger creation</p><p>You can create triggers associated with a game at any point while the game is running. The methods Game.ActiveTriggers.When(x, y) and Game.ActiveTriggers.After(x, y) assist with this.</p><ul><li><p>X is the graph to match on</p></li><li><p>Y is the graph to execute if a match occurs</p></li></ul><p>The following delegate events are fired during action queue processing:</p><ul><li><p>OnQueueing - a single action is about to be queued</p></li><li><p>OnQueued - a single action has just been queued</p></li><li><p>OnActionStarting - a single action is about to execute. Its arguments have not yet been popped off the result stack</p></li><li><p>OnAction - a single action has just executed</p></li></ul><p>Each event receives a QueueActionEventArgs which specifies the owning game, action source and the action in question along with any arguments supplied to it plus optional user data, along with the ability to cancel the action.</p><p>In addition, action handlers can be replaced outright by registering a handler with ReplaceAction&lt;T&gt; where T is the Action type to replace. This is particularly useful for eg. modifying random outcomes.</p><p>The following delegate events are fired during power history processing:</p><ul><li><p>OnPowerAction - a power action (entity creation, tag change etc.) has just been added to the power history</p></li></ul><p>Each event receives a PowerActionEventArgs which specifies the owning game and the PowerAction in question.</p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Game State Re-use Model</span></div><div id="ID3RBSection" class="collapsibleSection"><p>Brimstone supports re-using a game state in a number of ways:</p><ul><li><p>Naive deep copy</p></li><li><p>Copy-on-write cloning</p></li><li><p>Mass cloning</p></li><li><p>Parallel cloning</p></li><li><p>Action-based cloning</p></li><li><p>Rewind stack</p></li><li><p>PowerHistory import</p></li></ul><p>The re-use paradigm can be changed at will at any point during run-time.</p><p>To clone a game, use: var clonedGame = myGame.GetClone();</p><p>In this mode, Brimstone makes a complete copy of the game state including all entities, the action queue, result stack, active triggers.</p><p>Card definitions and the starting tags of entities are immutable and are not deep copied; only the references are updated. The PowerHistory is not cloned but chained as a linked list (see below).</p><p>The game state includes a list of which entities are in which zones. As an optimization, these entities are not cloned as they form part of the game's entity list. Instead, the references in the zone lists are updated to point to the copied entities in the cloned game.</p><p>This is the slowest but most time-measurable form of cloning.</p><p>To enable: Settings.CopyOnWrite = false</p><p>This is the default mode. Brimstone uses a proxy class to represent each entity and only copies the proxies when cloning. The base entities maintain a reference count of how many games are using them. When an entity in the cloned game is changed, that entity alone is deep copied with a new reference count of 1, and the original entity has its reference count decremented.</p><p>In this way, copy-on-write clones are much faster and consume less memory. They are particularly useful for game states which will be mostly read-only. We have typically experienced a 2.5x-3x speedup when using copy-on-write cloning over naive deep copy.</p><p>Additionally, copy-on-write clones can be made from other copy-on-write clones, such that an entity in a clone several levels deep will still refer to the original entity if it has not been modified.</p><p>Writing to an entity in a copy-on-write clone for the first time copies it, and as such the first modification to each entity will be slower than in a naive deep copy.</p><p>Copy-on-write cloning deep clones the action queue, result stack and active triggers as per naive deep copy.</p><p>Power History cloning is implemented by using a linked list approach whereby the cloned Power History is empty but points to the entry in the original power history where the clone was made. This is transparent and appears to the user as a single contiguous Power History log, even if the parent game subsequently receives new log entries.</p><p>IMPORTANT: Do not mix naive cloning and copy-on-write cloning within a single application. This may lead to undefined behaviour.</p><p>If you require many clones using either of the above modes, you can use the GetClones() helper to create a specified number of clones from a specified game:</p><p>var clones = myGame.GetClones(100000);</p><p>returns a List&lt;Game&gt; containing 100,000 clones of myGame.</p><p>NOTE: List&lt;T&gt; use O(n) time to add each new item, meaning that the cloning overhead becomes larger the more clones you make per call.</p><p>NOTE: If you do not need all of the clones in memory at once (ie. if you are only processing one at a time and then throwing the result away), use standard cloning instead to improve the performance and reduce the memory footprint of your application.</p><p>Parallel cloning allows cloning to use all available processor cores. It also enables you to safely clone games in a multi-threaded environment. Parallel cloning is enabled by default.</p><p>When parallel cloning is enabled, games are cloned in a thread-safe manner, even if you are only making one clone at a time or using a single thread. Parallel cloning is therefore slower than sequential cloning when running single-threaded applications and should be disabled.</p><p>Note that when using parallel tree search (see below), parallel cloning must be enabled too.</p><p>To disable: Settings.ParallelClone = false</p><p>IMPORTANT: Do not mix parallel and sequential cloning in a single game tree. This may lead to undefined behaviour.</p><p>
          Action-based cloning allows the game state to be automatically cloned before or after an action occurs. You can do this either by hooking OnActionStarting and/or OnAction (see above) to replace actions with an action that generates a clone instead, or by using the GameTree API to automatically build a tree of all possible game states resulting from a single action (see <a href="#h.1nerttr5024z">Working with random outcomes</a> below).
        </p>
          Rewind stack<sup><a href="#cmnt5">[e]</a></sup><p>The rewind stack allows a reversal of the Power History by storing a 2nd Power History containing the previous states of tags before they are changed. Rewind points can be marked and the points rewound to at any time.</p><p>In this way, clones can be avoided altogether in some cases by simply rewinding an action you wish to perform repeatedly each time it completes.</p>
          PowerHistory import<sup><a href="#cmnt6">[f]</a></sup><p>Full or partial game states can be imported from a variety of file formats to configure a game state.</p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Game State Manipulation</span></div><div id="ID4RBSection" class="collapsibleSection"><p>Now we understand Brimstone's model we can look at some examples on how to manipulate the game state at run-time.</p>Adding items<p>You can add QueueActions, ActionGraphs and List&lt;QueueAction&gt;s to the queue. These can be run immediately or deferred for later:</p><ul><li><p>Game.Action(source, action) queues an action and processes the entire queue immediately if it is not paused. If there are outstanding items in the queue, these are processed first. This method returns a single ActionResult which is the last item on the result stack after the queue has been fully processed.</p></li><li><p>Game.Queue(source, action) queues an action and returns immediately without processing</p></li></ul><p>The source is the actor who originates the action. For example, a Minion that is played uses itself as the action source.</p><p>If you need to get all of the items on the result stack, use Game.ActionQueue.EnqueueMultiResult(source, action). This function returns a List&lt;ActionResult&gt;.</p><p>Many objects in Brimstone provide helper functions so that you don't have to deal with the queue directly. For example, to damage a minion by 3, you simply write:</p><p>Minion.Hit(3);</p><p>By default, these actions run immediately. To queue them without executing instead, simply wrap each helper call you want to queue inside a lambda call to Game.Queue like this:</p><p>Game.Queue(() =&gt; Minion.Hit(3));</p><p>Note that since the actions are not actually executed, you cannot use any results you would normally get from them inside your lambda function. Doing so will cause an exception. For example, the following will not work:</p><p>Game.Queue(() =&gt; player.Give("Wisp").Play());</p><p>This is because we cannot use the output of Give as an input to Play since Give will not have executed yet.</p>Adding items to the front of the queue<p>You can use Game.ActionQueue.InsertDeferred to insert actions at the front of the queue. This is mostly useful when you are using an event handler to cancel an action and replace it with something else. The events OnQueueing and OnQueued do not fire when adding to the front of the queue.</p>Processing the queue<p>Unless you enqueue items deferred with Game.Queue as above, the queue will normally process immediately as soon as you call an action. If you have items waiting that you have enqueued earlier, you can process them as follows:</p><ul><li><p>Game.ActionQueue.ProcessAll() process all outstanding items in the queue and returns a List&lt;ActionResult&gt; of the result stack</p></li><li><p>Game.ActionQueue.ProcessOne() executes a single action and returns true on success, false on failure. Failure occurs when the queue is in a paused state (see below), the queue is empty or the action to be processed has been cancelled (see below)</p></li></ul><p>You can also:</p><ul><li><p>
              Check the size of the action queue with Game.ActionQueue.Count<sup><a href="#cmnt7">[g]</a></sup></p></li><li><p>Pause or unpause the queue by setting the boolean flag Game.ActionQueue.Paused. When the queue is paused, ProcessAll() and ProcessOne() do nothing, which means all helper functions that normally execute actions immediately will just queue them instead.</p></li></ul><p>For example, the code above is analogous to:</p><p>Game.ActionQueue.Paused = true;</p><p>Minion.Hit(3);</p><p>Game.ActionQueue.Paused = false;</p><p>Note that the queue does not process when you unpause it - you must call ProcessAll() or ProcessOne() after unpausing.</p>Queueing arbitrary actions<p>Sometimes you may want to queue an action that does not have a helper method. You can create any ActionGraph you like and queue it at any time.</p><p>For example, to deal 3 damage to a minion (equivalent of calling Hit above), you can write the action directly as follows:</p><p>myGame.Action(myMinion, Actions.Damage(myMinion, amount));</p><p>It is recommended that you use the helper methods for readability and future compatibility wherever possible, rather than queueing actions directly. Only queue actions directly where no corresponding helper method exists.</p>Passing user-defined data<p>Sometimes you may wish to pass custom data to the ActionQueue processor so you can track where the call to process the queue came from. This can be especially useful if you are using the same event handlers to handle many different games.</p><p>The custom data can be of any type and is supplied to event handlers in QueueActionEventArgs.UserData, which must be cast to the correct type.</p><p>To pass custom data:</p><ul><li><p>Game.ActionQueue.ProcessAll(myUserData)</p></li><li><p>Game.ActionQueue.ProcessOne(myUserData)</p></li></ul>
          Modifying the action queue<sup><a href="#cmnt8">[h]</a></sup><p>When an action is being queued</p><p>You can modify an action before it is queued by subscribing to the ActionQueue.OnQueueing event.</p><p>Example:</p><p>game.ActionQueue.OnQueueing += (o, e) =&gt; {</p><p>        ActionQueue queue = o as ActionQueue;</p><p>        if (e.Action is RandomChoice) {</p><p>                if (game.CurrentPlayer.Opponent.Board.Count &gt; 0) {</p><p>                        e.Game.Queue(e.Source, (Entity)game.CurrentPlayer.Opponent.Board[1]);</p><p>                        e.Cancel = true;</p><p>                }</p><p>        }</p><p>};</p><p>This code checks to see if a RandomChoice has been queued. If so, and the current player's opponent has at least one minion on board, the choice is replaced with the opponent's left-most minion. Setting the Cancel flag prevents the intercepted action from being queued. This overrides any previous entity selection that would have been fed into RandomChoice as an argument.</p><p>Note that in reality you will need a more specific set of conditions - the above example works when the selected minion will be damaged, but you do not want this behaviour when choosing eg. a card from a deck.</p><p>This example shows how random events in the game can be replaced with deterministic ones, which is useful for AI tree searching.</p><p>When an action is about to start</p><p>You can also modify actions as they are starting by subscribing to the ActionQueue.OnActionStarting event, and inspect or replace arguments that will be passed to the action by modifying the contents of QueueActionEventArgs (e in the code below):</p><ul><li><p>Source property allows you to get or set the source of the action</p></li><li><p>Action property allows you to get or set the action</p></li><li><p>Args property allows you to get or set the arguments to the action</p></li><li><p>Cancel property allows you to abort the action before it executes. This also defers the rest of the action queue</p></li></ul><p>Example:</p><p>game.ActionQueue.OnActionStarting += (o, e) =&gt; {</p><p>        ActionQueue queue = o as ActionQueue;</p><p>        if (e.Action is Damage) {</p><p>                e.Args[Damage.DAMAGE] = 2;</p><p>        }</p><p>};</p><p>This code checks to see if the action about to execute is Damage, and if so, replaces the damage amount with 2, causing all Damage actions to always do exactly 2 damage regardless of the originally specified argument.</p><p>Similarly to above, you can cancel the action by setting the Cancel flag if you don't want it to run at all.</p><p>All actions have a set of arguments with names such as DAMAGE above. You can look at the constant definitions in Actions.cs to find which actions have which argument names so that you can refer to them in events.</p><p>Replacing all occurrences of an action</p><p>ActionQueue.ReplaceAction&lt;TAction&gt; can be used when you want to replace every instance of a specific action type with your own code. Each action can have at most one replacement. Replaced actions have the following properties:</p><ul><li><p>OnActionStarting executes as normal for the original action</p></li><li><p>The original action does not execute</p></li><li><p>OnAction does not execute</p></li><li><p>Neither the original nor replacement action is stored in the ActionQueue history log</p></li><li><p>Queue processing stops when the action completes even if there are more items remaining</p></li></ul><p>Therefore, using this method essentially kills queue processing (but leaves the remaining queue items intact for later processing), and is mostly useful for splicing in different actions to the front of the queue with InsertDeferred.</p>
          Modifying the result stack<sup><a href="#cmnt9">[i]</a></sup><p>You can modify the top action on the result stack by using ActionQueue.ReplaceArg, eg:</p><p>Game.ActionQueue.ReplaceArg(2)</p><p>replaces the top item on the stack with 2.</p><p>You can use ActionQueue.ReplaceArgs to replace multiple stack arguments at the same time.</p><p>ReplaceArg and ReplaceArgs take an ActionResult or a list of ActionResults respectively as their arguments.</p><p>You can execute actions not normally possible in the game.</p><ul><li><p>Player.Give(Card) generates a new entity from a card and puts it in the player's hand</p></li><li><p>CanBeDamaged.Hit(int) damages the specified damageable entity by the specified amount</p></li><li><p>
              More to come...<sup><a href="#cmnt10">[j]</a></sup></p></li></ul>Creating new entities<p>
          To create a new in-game entity, use the Minion, Spell and Weapon<sup><a href="#cmnt11">[k]</a></sup> classes.
        </p><p>First, create an entity based on a card:</p><p>var myMinion = new Minion("Chromaggus");</p><p>(you can also use a card ID or an existing Card object as the constructor argument)</p><p>Then assign a location to it:</p><p>myGame.CurrentPlayer.Hand.MoveTo(Entity: myMinion, ZonePosition: 1);</p><p>(the ZonePosition argument is optional - if not specified, the entity will be placed right-most in the zone, or at the bottom of the deck if placing into a deck)</p><p>Until an entity is placed into a zone, it is in an orphan state with no owning game or controlling player. Once you move an entity into a zone, it automatically becomes owned by the player or game which controls the zone. If you subsequently move the entity into a zone owned by another player, ownership is transferred automatically. You cannot move entities between games.</p>Direct tag manipulation<p>To change an entity's tags directly, use the corresponding tag properties on the object. For example, to assign one more point of damage to a minion:</p><p>myMinion.Damage += 1;</p><p>Changes made this way will be reflected in the PowerHistory if it is enabled.</p><p>Imagine a scenario where a Boom Bot is about to die (causing 1-4 damage to an opponent character). You could repeat this many times as follows:</p><p>var firstboombotId = game.Player1.Board.First(t =&gt; t.Card.Name == "Boom Bot").Id;</p><p>for (int i = 0; i &lt; 100000; i++) {</p><p>        Game cloned = (Game) game.CloneState();</p><p>        ((Minion) cloned.Entities[firstboombotId]).Hit(1);</p><p>}</p><p>(Note: we take the entity ID of the desired Boom Bot before cloning so we don't have to search for it 100,000 times)</p><p>This works, but repeats a lot of unnecessary work in creating the same new set of actions in the queue 100,000 times.</p><p>Instead, we can clone after the Boom Bot has been killed but before its Deathrattle executes as follows:</p><p>var BoomBot = game.Player1.Board.First(t =&gt; t.Card.Id == "Boom Bot") as Minion;</p><p>game.ActionQueue.OnAction += (o, e) =&gt; {</p><p>        ActionQueue queue = o as ActionQueue;</p><p>        if (e.Action is Death &amp;&amp; e.Source == BoomBot) {</p><p>                for (int i = 0; i &lt; 100000; i++) {</p><p>                        Game cloned = (Game)game.CloneState();</p><p>                        cloned.ActionQueue.ProcessAll();</p><p>                }</p><p>        }</p><p>};</p><p>BoomBot.Hit(1);</p><p>The Hit method queues up a Damage action on the Boom Bot. The Boom Bot dies, and its Death action is queued. This in turn queues the ActionGraph which selects a random enemy character, then a random number between 1 and 4, then applies damage to the selection. The Death action then returns and ActionQueue.OnAction is fired. At this point, the queue contains only the deathrattle actions for the Boom Bot. We then clone the game (which also clones the queue) and run the queue on each clone. This gives a performance improvement of approximately 20% in the above example where there are no minions on-board with damage triggers (eg. Acolyte of Pain), and a 100% or greater increase when there are.</p><p>Every item in the Power History has a sequence number starting with 0 (zero) when a new non-cloned game is created. When a game is cloned, the current sequence number is copied to the child game and a new log is started. By using a linked list in this fashion, we save the need to copy the entire Power History when cloning a game.</p><p>Thus when iterating over a tree of games to a particular leaf game, the sequence numbers of the Power History log are always contiguous. If new entries are added to a parent game's Power History, that game's sequence number will continue to increment as if no clone had occurred. Because the child game stores the sequence number at the point at which it was cloned, an accurate Power History of the entire game can still be constructed.</p>Subscribing to PowerHistory events<p>The PowerHistory.OnPowerAction event fires whenever a new item is added to the PowerHistory log.</p>PowerHistory deltas<p>A delta is the change in the PowerHistory log between two specific points in time. You will generally want to look at deltas to understand what changes have occurred to the game state as the result of a specific action, or to compare game actions for equality.</p><ul><li><p>Game.PowerHistory.DeltaSince(Game) returns the delta from the point at which the specified game was created to the end of the PowerHistory on the game the method is being called on. The specified Game must be an ancestor. This allows you to fetch the precise delta from the point where you cloned from a specific known parent game</p></li><li><p>Game.PowerHistory.DeltaTo(int) returns the local delta (the delta of this clone only) up to but not including the specified sequence number</p></li><li><p>Game.PowerHistory.CrunchedDelta(List&lt;PowerAction&gt;) takes a log or partial log and returns only the most recently changed tags for each changed entity, therefore giving the smallest possible delta that still results in the same game state</p></li></ul><p>See below for information about comparing PowerHistory logs for equality.</p><p>You can add arbitrary event triggers to the game just as you can to card definitions.</p><p>Example:</p><p>game.ActiveTriggers.When(</p><p>Actions.Damage(Actions.AllMinions),</p><p>Actions.Give(</p><p>Actions.CurrentPlayer, Cards.FromName("Wisp")));</p><p>This will cause the current player to be given a new Wisp every time any minion on the board is damaged.</p><p>Since ActionGraph automatically converts functions to Func actions, you can more usefully create a trigger which calls an arbitrary function:</p><p>game.ActiveTriggers.When(</p><p>Actions.Damage(Actions.AllMinions), </p><p>(Action&lt;IEntity&gt;)(g =&gt; {</p><p>                Console.WriteLine("A MINION IS ABOUT TO BE DAMAGED!");</p><p>}));</p><p>The game object is supplied in g.</p><p>The main differences between attaching an event trigger and intercepting an action with ActionQueue.OnActionStarting or ActionQueue.OnAction are:</p><p>With triggers -</p><ul><li><p>Trigger match arguments can be used to filter which events are captured</p></li><li><p>Triggers queue an ActionGraph of your choice</p></li><li><p>Triggers are much slower</p></li></ul><p>With delegate events -</p><ul><li><p>The event fires on every action and always calls a user-defined callback function</p></li><li><p>Nothing is queued unless the event handler queues something</p></li><li><p>If you want to filter what is captured, you must check the action and its arguments in the event handler</p></li><li><p>Delegate events are much faster</p></li></ul></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID5RB')" onkeypress="SectionExpandCollapse_CheckKey('ID5RB', event)" tabindex="0"><img id="ID5RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Game State and Entity State Equality</span></div><div id="ID5RBSection" class="collapsibleSection"><p>Testing game states for equivalence is crucial in AI applications and search tree pruning.</p><ul><li><p>Equality in this document means that two game or entity states are identical in every way</p></li><li><p>Equivalent in this document means that two game or entity states are functionally the same and behave identically from the player's perspective, but may differ. For example, two identical minions on the board may have different entity IDs, or two cards in a player's hand may have swapped positions. This has no functional effect on the game but means that the games are equivalent but not equal.</p></li></ul><p>For equivalence testing, Brimstone makes extensive uses of hashes. Hashes are a mathematical computation based on any input data (in this case, the game state) which are designed to be fast to compute and unlikely to produce the same hash for two different sets of data.</p><p>Technically speaking, hashes cannot be used to test for equality, only inequality: two sets of data having different hashes are guaranteed to be different, but two sets of data having the same hash are not guaranteed to be the same. The case where two different sets of data produce the same hash is called a hash collision. For our usage, such hash collisions are extremely rare and we therefore accept this compromise and use hashes to compare game states for equivalence.</p><p>Brimstone provides various ways to test two game states for equality or equivalence, each with advantages and disadvantages:</p><ul><li><p>
              PowerHistory equivalence allows you to test the PowerHistory from any two games - including cloned games with an arbitrary number of ancestors - for equality. This can be ordered equivalence - where the order of tag changes matter and is essentially pure equality testing - or unordered equivalence, where tag change order is ignored. This form of testing also allows you to ignore the position of cards in hand if desired as an optional flag. You can also specify tags to include or exclude in the comparison.<sup><a href="#cmnt12">[l]</a></sup> PowerHistory equivalence is the slowest but most flexible form of equivalence testing.<p /></p></li><li><p>
              PowerHistory hash equality allows you to compare a running hash which is updated every time a new PowerHistory entity is created to that of another game. The PowerHistory class maintains two hashes: OrderedHash and UnorderedHash, which mirror the PowerHistory equivalence tests. These are much faster but do not allow you to filter tags or ignore card positions in hand. The PowerHistory hashes are copied when a game is cloned, so the comparison requires no calculation and is extremely fast.<p /><p />However you may experience unexpected behaviour: consider the case where a 1-health minion is killed by 2 or 3 damage. As far as the PowerHistory is concerned, these are different game states and will have different hashes. This is because every tag change is included in the hash, regardless of whether it affects the overall game state or not. This is by design: the PowerHistory object has no way of knowing which tags are relevant and which are not.<p /></p></li><li><p>Fuzzy hash equality can be used to compare two entities for equivalence using a specific set of rules:</p></li></ul><ul><li><p>The entity ID is ignored. This allows otherwise identical spells and minions - or minions which have swapped board positions but are otherwise identical - to be considered equivalent</p></li><li><p>The zone position of entities in each player's hand is ignored</p></li><li><p>The base immutable tags for the card associated with the entity are ignored, but the card ID is included to represent these starting tags in an efficient way</p></li><li><p>All other tags are included, but using only the latest tag values for each entity, therefore the order of tag changes - or tag changes that were overridden by subsequent changes to the same tag - are ignored</p></li></ul><p><p />Fuzzy hash equality is the fastest way to compare two entities. Fuzzy hashes are re-calculated only when requested, and the re-calculated value is cached until the entity is next changed. Even when the entity is changed, the hash will not be re-calculated unless the programmer requests it.<p /><p />Note that using fuzzy hash equality on a Game object only compares the tags of the Game entity itself, not the entire game state.
        </p><ul><li><p>Fuzzy game hash equality can be used to compare two game states for equivalence. The hash is created as follows:</p></li></ul><ul><li><p>An ordered hash is created from all of the minions on the game board using their fuzzy hashes</p></li><li><p>An unordered hash is created from all of the other entities in the game using their fuzzy hashes</p></li><li><p>The two hashes are combined</p></li></ul><p>This ensures that you cannot get the same game hash for two games which have minions swapped on board but are otherwise identical, while also not caring in which order entities have been changed.</p><p><p />Fuzzy game hash equality is the fastest way to compare two game states for functional equivalence. Fuzzy game hashes are re-calculated only when requested, and the re-calculated value is cached.
        </p><p>You can control whether hashes are cached and the default equivalence scheme with the following settings:</p><ul><li><p>Settings.EntityHashCaching (default: enabled) - cache fuzzy entity hashes</p></li><li><p>Settings.GameHashCaching (default: enabled) - cache fuzzy game hashes</p></li><li><p>Settings.UseGameHashForEquality (default: enabled) - use fuzzy game hashes to compare games for equivalence; if disabled, uses the PowerHistory delta</p></li></ul><p>Directly: entity1.FuzzyHash == entity2.FuzzyHash</p><p>Using the default equivalence scheme: game1.EquivalentTo(game2)</p><p>Using fuzzy hashing: game1.Entities.FuzzyGameHash == game2.Entities.FuzzyGameHash</p><p>Using PowerHistory deltas: game1.PowerHistory.EquivalentTo(game2.PowerHistory)</p><p>Using PowerHistory hashes: game1.PowerHistory.OrderedHash == game2.PowerHistory.OrderedHash or game1.PowerHistory.UnorderedHash == game2.PowerHistory.UnorderedHash</p><p>By default, PowerHistory delta equivalence will ignore the order of tag changes and the position of cards in the players' hands. If you want to test for pure equality, use:</p><p>game1.PowerHistory.EquivalentTo(game2.PowerHistory, Ordered: true, IgnoreHandPosition: false)</p><p>The Game.Changed property returns true if the game state has changed since its fuzzy game hash was last re-calculated. If you are only interested in testing whether a specific action causes the game state to change, you can use this property to avoid re-calculating the entire fuzzy game hash.</p><p>As soon as you access the fuzzy game hash (which may also include comparing a game with another, searching for it in or adding it to a collection etc.), Game.Changed will return false until the next change.</p><p>If you want to ignore all changes before a certain point, you don't need to fetch the fuzzy game hash; instead, you can set Game.Changed to false, perform your action, then check the property again to see if it returns true.</p><p>Oftentimes you will want to keep a series of games or entities in a collection and filter out any duplicates. Brimstone provides the FuzzyEntityComparer and FuzzyGameComparer classes for this, both of which implement IEqualityComparer&lt;T&gt;, allowing them to be used as a KeyComparer in keyed collections.</p><p>The mechanics of both comparer classes are identical, so we will just focus on FuzzyGameComparer below.</p><p>We recommend using a HashSet&lt;IEntity&gt; or HashSet&lt;Game&gt; to store large amounts of games. HashSet&lt;T&gt; executes insertions, removals and contains-tests in O(1) time.</p><p>If you have a list of games in another collection, you can create a collection of just the fuzzy unique games as follows:</p><p>var myUniqueGames = new HashSet&lt;Game&gt;(myGames, new FuzzyGameComparer());</p><p>Alternatively, you can create an empty collection:</p><p>var myUniqueGames = new HashSet&lt;Game&gt;(new FuzzyGameComparer());</p><p>Then, each time you add a new game with:</p><p>myUniqueGames.Add(newGame);</p><p>newGame will be automatically discarded if it is a duplicate of a game state already in the collection.</p><p>To test if a particular game state is already in the collection, simply use:</p><p>myUniqueGames.Contains(gameToTest)</p><p>IMPORTANT: Hash keys in .NET collections are immutable. This means if the state of a game or entity in a collection changes, its hash key will not be updated with the entity's current fuzzy hash. Note the following code:</p><p>var myHashSet = HashSet&lt;Game&gt;(new FuzzyGameComparer());</p><p>myHashSet.Add(game);</p><p>
          myHashSet.Contains(game)   // returns true<p />game.Player1.Give("Wisp");<p />myHashSet.Contains(game)   // returns false<p /></p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID6RB')" onkeypress="SectionExpandCollapse_CheckKey('ID6RB', event)" tabindex="0"><img id="ID6RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Game Tree Modelling</span></div><div id="ID6RBSection" class="collapsibleSection"><p>Game trees are a fundamental building block for both classic game AIs and those using Deep Machine Learning (ML). Brimstone provides you with powerful, first-in-class tools for modelling Hearthstone game trees:</p><ul><li><p>The GameTree class allows you to quickly create an n-tree with an existing game as the root node</p></li><li><p>The GameNode class allows you traverse a game's parent and children, and create new branches</p></li><li><p>Trees are thread-safe and can be built and traversed both asynchronously and in parallel using either depth-first or breadth-first search; users can implement their own search algorithms</p></li><li><p>GameNode can be derived from to include custom data and behaviour. Brimstone comes with WeightedGameNode (for decision trees) and ProbabilisticGameNode (for non-deterministic outcomes) out of the box</p></li><li><p>
              The ITreeActionWalker<sup><a href="#cmnt13">[m]</a></sup> interface lets you build a game tree automatically from game actions
            </p></li><li><p>The game state equivalence tools allow duplicate nodes to be pruned rapidly</p></li><li><p>The built-in RandomOutcomeSearch tree builder allows you to fetch all the possible game states for a non-determinstic play - together with their probabilities - with a single line of code</p></li></ul><p>NOTE: Game trees allow duplicate game states by default. You must prune duplicates yourself if desired.</p><p>IMPORTANT: If you are adding nodes to a tree from multiple threads, you must enable the ParallelClone setting.</p><ul><li><p>GameNode is a basic node which just contains a Game and references to its parent and children.</p></li><li><p>WeightedGameNode additionally stores a weighting in the Weight property from 0.0-1.0. This can be used for any purpose you wish, and can be interpreted as a weight on the edge from the parent to the node, or on the node itself. Typically used for decision trees.</p></li><li><p>ProbabilisticGameNode is a WeightedGameNode which additionally stores a probability of occurrence in the Probability property from 0.0-1.0. This is automatically populated as the Probability of the parent node multiplied by the Weight of the current node. Therefore, when creating non-deterministic trees, the Weights of all the direct children of a node specify the probability of that game state occurring assuming the parent game state occurs, while the Probability of any node in the tree gives the probability of reaching that node from the root node. Typically used for determining the likelihood of random outcomes.</p></li><li><p>You can also derive your own node types. The implementation must include a constructor which forwards all of the base class's constructor arguments.</p></li></ul><ul><li><p>The static helper function GameTree.From(Game) returns a GameTree using GameNodes, creating a root node using the specified game</p></li><li><p>To create GameTrees using other node types, use new GameTree&lt;NodeType&gt;(new NodeType(Game, ...)) - NodeType must derive from GameNode</p></li><li><p>RootNode (property) returns the root node of the tree</p></li><li><p>NodeCount (property) returns the total number of nodes in the tree</p></li><li><p>LeafNodeCount (property) returns the total number of leaf nodes in the tree</p></li></ul><p>By default, each node in the tree tracks its child nodes. This can be expensive performance-wise. If you do not require traversal via child nodes, disable child tracking by setting the TrackChildren property of the root node to false when creating the tree as follows:</p><p>var tree = new GameTree&lt;NodeType&gt;(new NodeType(Game, TrackChildren: false, ...));</p><p>There are several ways to add nodes to the tree:</p><ul><li><p>GameNode node.Branch() clones the game in node and creates a new child node from it</p></li><li><p>IEnumerable&lt;GameNode&gt; node.Branch(quantity) clones the game in node the specified number of times and creates the corresponding number of new child nodes</p></li><li><p>void node.AddChild(GameNode) adds a new child node from an existing node</p></li><li><p>GameNode node.AddChild(Game) creates a new child node containing Game and returns it</p></li><li><p>HashSet&lt;GameNode&gt; node.AddChildren(IEnumerable&lt;Game&gt; Children) creates a set of new child nodes from the specified games and returns the nodes</p></li><li><p>void AddChildren(IEnumerable&lt;GameNode&gt; Children) adds the specified existing nodes as child nodes</p></li></ul><p>WeightedGameNode and ProbabilisticGameNode provide additional overloads allowing you to specify the Weight(s) of the child nodes.</p><ul><li><p>Game (property) returns the Game encapsulated by the node</p></li><li><p>Parent (property) returns the parent node (or null if it is the root node)</p></li><li><p>Children (property) returns a HashSet of all the direct child nodes if child tracking is enabled (otherwise null)</p></li></ul><p>The RandomOutcomeSearch GameTree-derived class leverages game trees, action queue events and replacement together with cloning and equivalence tests to produce a probability set of all the possible outcomes given a starting game state and an action with a non-deterministic result.</p>Game state probability maps<p>For example, to get all the possible outcomes from playing Arcane Missiles (which we will assume we hold a reference to in ArcaneMissiles):</p><p>var outcomes = RandomOutcomeSearch.Find(game, () =&gt; ArcaneMissiles.Play());</p><p>This function returns a Dictionary&lt;Game, double&gt; of fuzzy unique game states and their corresponding chance of occurring.</p><p>If you are using a GameTree&lt;ProbabilisticGameNode&gt; or a derived node thereof as your game tree, you can use an overload in ProbabilisticGameNode to easily add these results to your tree with the correct weightings:</p><p>var childNodes = myNode.AddChildren(outcomes);</p><p>IMPORTANT: The lambda expression in the call to RandomOutcomeSearch is run with the action queue paused, therefore you cannot rely on previous action results from within the expression itself. For best practice, use code which only generates one action in the expression.</p>Inspecting the generated tree<p>To inspect the constructed tree, use Build instead of Find. This will return the resulting tree instead of a list of games. To fetch the fuzzy, unique games from the tree call GetUniqueGames() on the returned tree object.</p><p>NOTE: Child tracking is disabled on trees generated by RandomOutcomeSearch for performance reasons.</p>Sequential vs parallel tree builds and algorithms<p>By default, RandomOutcomeSearch builds game trees in parallel using breadth-first search (BFS). This default is suitable for most applications but there are some scenarios in which you may wish to use sequential (single-threaded) builds - for example if the tree is expected to be very small - or you may wish to use your own algorithm.</p><p>For full control, create a RandomOutcomeSearch using the following constructor arguments:</p><ul><li><p>Game - the starting game state</p></li><li><p>SearchMode - an ITreeActionWalker specifying the build and pruning algorithm. Defaults to BreadthFirstActionWalker. Built-in alternatives are DepthFirstActionWalker and NaiveActionWalker. You can also specify your own implementation.</p></li><li><p>Parallel - if not specified, uses the application-wide default in Settings.ParallelTreeSearch. Otherwise, specify true to enable parallel search and false to disable it.</p></li></ul><p>To build the tree, call Run(action) on the created object.</p><p>For BreadthFirstActionWalker, you can also select the maximum number of processor cores to use and the minimum number of nodes required at the tree depth being processed before the work is split into parallel operations. This is because starting parallel work has a small overhead associated with it. By default the search will use all but one CPU core, and will not parallelize unless there are at least 100 nodes at the current depth. To change this, set the following properties on BreadthFirstActionWalker before you pass it to the RandomOutcomeSearch constructor:</p><ul><li><p>MaxDegreesOfParallelism - the number of CPU cores to use</p></li><li><p>MinNodesToParallelize - the minimum number of nodes required at a particular depth before that depth is parallelized</p></li></ul><p>IMPORTANT: If you enable parallel tree search, you must enable parallel cloning with Settings.ParallelClone as well.</p><p>NOTE: NaiveActionWalker is extremely slow and should only be used for debugging purposes as it is (virtually) guaranteed to give the correct results every time.</p><p>NOTE: At the present time, BreadthFirstTreeWalker is optimized to prune duplicate nodes (fuzzy game states) after processing each tree depth, and is therefore a magnitude faster than DepthFirstTreeWalker. Do not change the default search algorithm unless you have a good reason to.</p>Search performance<p>The following graph shows the performance of playing Arcane Missiles with the number of missiles adjusted from 1-10, on a board consisting of 5 Bloodfen Raptors and 2 Boom Bots per side, using BreadthFirstTreeWalker. The Boom Bots are modified to only attack minions in this test, for historical reasons. The Boom Bots are all positioned on the far right of each side of the board.</p><p>Test machine: Core i7-2600K, 16GB DDR3-1600 RAM, Windows 10, Brimstone Release build against AnyCPU architecture</p><div class="mediaNear"><div class="caption">Tree Search Performance</div><img alt="Tree Search Performance" src="../media/TreeSearchPerformance.png" /></div><p>Both sequential and parallel BFS times scale approximately linearly with the number of fuzzy unique game states produced. Notice that that parallel version only gives a small performance improvement compared to the sequential algorithm. This is due to the fact that each depth must be searched completely before the next depth can begin in order to facilitate same-depth node pruning, and because game cloning in a parallel environment must be thread-safe, which introduces synchronization locks.</p><p>The speed-up from depth-first parallel vs sequential search is vast, however even the 2-missile search takes longer than the 10-missile search using BFS.</p><p>Nonetheless, we believe this to be by far the fastest Hearthstone tree search implemented to date. The 10-missile test generates 104,715 clones, processes the ActionQueue on each clone - pruning 86,752 of them in fuzzy equivalence testing - and returns 2,170 unique game states all in just 3.3 seconds.</p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID7RB')" onkeypress="SectionExpandCollapse_CheckKey('ID7RB', event)" tabindex="0"><img id="ID7RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Asynchronous (non-blocking) API</span></div><div id="ID7RBSection" class="collapsibleSection"><p>Brimstone includes an API for running computationally expensive operations as background tasks. Instead of running sequentially, you can use the asynchronous API to request a placeholder value - or promise object - in place of the actual result for a task, and do other work while you wait for the task to complete. In C#, promises are implemented as Task&lt;T&gt; objects.</p><p>All of the methods in Brimstone which return promises have the same names as the regular methods, suffixed with Async. Each returns a Task&lt;T&gt; where T is the type that the regular method call would return.</p><p>IMPORTANT: Brimstone's asynchronous API is based on the async/await pattern (TPL). To avoid deadlocks, you must design your application to use async/await "all the way down". Don't mix regular and asynchronous API calls to Brimstone in the same application if it can be avoided.</p><p>ActionQueue</p><ul><li><p>ProcessAllAsync(...)</p></li><li><p>ProcessOneAsync(...)</p></li></ul><p>RandomOutcomeSearch</p><ul><li><p>RunAsync(...)</p></li><li><p>BuildAsync(...)</p></li><li><p>FindAsync(...)</p></li></ul><p>Game</p><ul><li><p>
              GetClonesAsync(...)<sup><a href="#cmnt14">[n]</a></sup></p></li></ul><p>To run a task and relinquish control to the caller until the task completes:</p><p>await methodAsync(...);</p><p>(must be in a function denoted as async)</p><p>To start a task and continue (non-blocking execution):</p><p>var task = methodAsync(....);</p><p>To check if a task is completed:</p><p>task.IsCompleted</p><p>To wait for the task to complete:</p><p>await task;</p><p>To get the result of the task (type T):</p><p>task.Result</p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID8RB')" onkeypress="SectionExpandCollapse_CheckKey('ID8RB', event)" tabindex="0"><img id="ID8RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Additional Tools</span></div><div id="ID8RBSection" class="collapsibleSection"><p>Game implements IFormattable so that you can display the game state in more convenient ways. The format specifiers are as follows:</p><ul><li><p>G (General) - displays the game hash, board and hand state for each player with full card names and tags on a single line with no formatting, and the complete PowerHistory log (one line per item)</p></li><li><p>S (Short) - displays the game hash, board state for each player using only the first letter of each word in each card, damage in brackets and no other tags (one player per line), plus the last 20 entries in the PowerHistory log</p></li><li><p>s (super-short) - displays the same information as S but without the PowerHistory log</p></li></ul><p>Brimstone includes the Benchmarks project which allows you to define and run benchmarks with selected filters. New benchmarks can be defined in BenchmarkDefinitions.cs in the project.</p><p>When the benchmarks have completed, the output is written to benchmarks.csv in the working directory and can be imported into any spreadsheet application.</p><p>IMPORTANT: Benchmarks should be run at the command-line and compiled in Release mode to ensure accurate results. The application will warn you when running in Debug mode.</p>Output<p>Each benchmark produces 4 time-to-complete results (7 in extended mode - see below):</p><ul><li><p>All optimizations enabled</p></li><li><p>Parallel tree search disabled</p></li><li><p>Copy-on-write cloning disabled</p></li><li><p>Zone caching disabled</p></li><li><p>Entity and game fuzzy hash caching disabled</p></li><li><p>Hash-for-equivalence testing disabled (uses PowerHistory log instead)</p></li><li><p>All optimizations disabled</p></li></ul><p>Parallel cloning is always enabled unless specifically disabled in the benchmark test.</p>Command-line options<ul><li><p>--filter=X - only run tests whose short name contains X</p></li><li><p>--timeout=X - stop tests which take longer than X milliseconds to run (note: having a timer for this creates a small performance penalty in the results; do not use if you need very accurate benchmarks)</p></li><li><p>--extended - run all 7 tests per benchmark (very slow)</p></li></ul><p>Brimstone comes with a Visualizer tool to help you trace the flow of game scripts you have written for testing purposes. This can include any hard-coded game or AI client using the Brimstone API that you like. The visualizer allows you to step through all changes to the ActionQueue, ResultStack and PowerHistory one at a time, essentially acting as a step-through debugger for your game code.</p><div class="mediaNear"><div class="caption">Brimstone Visualizer</div><img alt="Brimstone Visualizer" src="../media/BrimstoneVisualizer.png" /></div><p>The script files are simply a compiled C# class saved as a DLL. To create a game script, use the following steps:</p><ol><li><p>Create a new C# Class Library project</p></li><li><p>Add References to Brimstone and BrimstoneVisualizer</p></li><li><p>Add the following skeleton code:</p></li></ol><p>using Brimstone;</p><p>using BrimstoneVisualizer;</p><p>namespace BrimstoneGameScript</p><p>{</p><p>    public class BrimstoneGame : IBrimstoneGame</p><p>        {</p><p>                public Game SetupGame() {</p><p>                        var game = new Game(HeroClass.Hunter, HeroClass.Warlock, PowerHistory: true);</p><p>                        // Your game setup code...</p><p>                        return game;</p><p>                }</p><p>                public void PlayGame(Game Game) {</p><p>                        // Your gameplay code...</p><p>                }</p><p>        }</p><p>}</p><p>4. Add game setup and gameplay code as desired</p><p>5. Compile</p><p>You can then load the output DLL into BrimstoneVisualizer and step through the game.</p></div><div id="ID9RBSection" class="collapsibleSection"><p>---</p><p>First draft: June 27th 2016</p><p>Update 1: July 27th 2016</p><p>Update 2: August 23rd 2016</p><p>Written by Katy Coe</p><p><a href="#cmnt_ref1">[a]</a>Hero powers are not yet implemented
        </p><p><a href="#cmnt_ref2">[b]</a>Work in progress
        </p><p><a href="#cmnt_ref3">[c]</a>Not implemented yet
        </p><p><a href="#cmnt_ref4">[d]</a>The way entities are selected has been changed. This section will be updated when the rules are finalized.
        </p><p><a href="#cmnt_ref5">[e]</a>Not yet implemented
        </p><p><a href="#cmnt_ref6">[f]</a>Not yet implemented
        </p><p><a href="#cmnt_ref7">[g]</a>This is going to be simplified soon
        </p><p><a href="#cmnt_ref8">[h]</a>Helper functions will be added to simplify this
        </p><p><a href="#cmnt_ref9">[i]</a>DEPRECATED - This is still possible but is no longer the recommended way to modify arguments. Modify QueueActionEventArgs.Args in OnActionStarting before the action executes instead.
        </p><p><a href="#cmnt_ref10">[j]</a>Implement
        </p><p><a href="#cmnt_ref11">[k]</a>Weapons are not yet implemented
        </p><p><a href="#cmnt_ref12">[l]</a>Not implemented yet
        </p><p><a href="#cmnt_ref13">[m]</a>This API is implemented but the surface not finalized yet
        </p><p><a href="#cmnt_ref14">[n]</a>Not yet implemented
        </p></div></div></div><div id="pageFooter" class="pageFooter"><a href="http://discord.me/hearthstoneworkinggroup">Join us on Discord</a><br /><p>Hearthstone Working Group 2016 - Part of HearthSim.info</p></div></body></html>